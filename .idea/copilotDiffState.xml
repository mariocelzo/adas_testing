<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/selection_result.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/selection_result.py" />
              <option name="originalContent" value="import os&#10;import json&#10;import numpy as np&#10;import pandas as pd&#10;from sklearn.preprocessing import MinMaxScaler, OneHotEncoder&#10;from sklearn.metrics import pairwise_distances&#10;from datetime import datetime&#10;&#10;&#10;# --- Funzioni di Caricamento e Estrazione Dati ---&#10;&#10;def load_scenarios_from_folder(folder_path):&#10;    &quot;&quot;&quot;&#10;    Carica tutti i file JSON da una cartella specificata, inclusi quelli nelle sottocartelle.&#10;    Ogni file JSON è atteso essere una LISTA di eventi.&#10;    Il codice estrarra' il PRIMO evento come rappresentativo dello scenario.&#10;    &quot;&quot;&quot;&#10;    scenarios = []&#10;    print(f&quot;Caricamento scenari dalla cartella: {folder_path} (e sottocartelle)&quot;)&#10;    if not os.path.exists(folder_path):&#10;        print(f&quot;⚠️ Attenzione: La cartella '{folder_path}' non esiste.&quot;)&#10;        return []&#10;&#10;    # Utilizza os.walk per attraversare l'albero delle directory&#10;    for root, _, files in os.walk(folder_path):&#10;        for filename in files:&#10;            if filename.endswith(&quot;.json&quot;):&#10;                file_path = os.path.join(root, filename)  # Usa 'root' per costruire il percorso completo&#10;                try:&#10;                    with open(file_path, 'r') as f:&#10;                        data = json.load(f)&#10;&#10;                        if isinstance(data, list) and data:&#10;                            if data:  # Assicurati che la lista non sia vuota&#10;                                scenario_event_data = data[0]&#10;                                scenario_event_data['original_filename'] = filename&#10;                                scenarios.append(scenario_event_data)&#10;                            else:&#10;                                print(f&quot;⚠️ Attenzione: Il file {filename} è una lista vuota. Saltato.&quot;)&#10;                        else:&#10;                            print(&#10;                                f&quot;❌ Errore: Il file {filename} non contiene una lista valida di eventi o ha un formato inatteso. Saltato.&quot;)&#10;&#10;                except json.JSONDecodeError as e:&#10;                    print(f&quot;❌ Errore di decodifica JSON nel file {filename}: {e}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;❌ Errore generico durante la lettura/elaborazione del file {filename}: {e}&quot;)&#10;    print(f&quot;Caricati {len(scenarios)} scenari.&quot;)&#10;    return scenarios&#10;&#10;&#10;def extract_collisions(scenarios):&#10;    &quot;&quot;&quot;&#10;    Estrae un flag binario (1 se c'è una collisione, 0 altrimenti) per ogni scenario.&#10;    Controlla 'event_type' direttamente nell'oggetto scenario (che è un singolo evento).&#10;    &quot;&quot;&quot;&#10;    collision_flags = []&#10;    for s in scenarios:&#10;        has_collision = 1 if s.get(&quot;event_type&quot;) == &quot;collision&quot; else 0&#10;        collision_flags.append(has_collision)&#10;    return collision_flags&#10;&#10;&#10;def extract_exec_times(scenarios):&#10;    &quot;&quot;&quot;&#10;    Estrae il tempo di esecuzione di ciascuno scenario.&#10;    Poiché il JSON non contiene 'simulation_duration_seconds' globale,&#10;    si assume una durata fissa.&#10;    &quot;&quot;&quot;&#10;    exec_times_list = []&#10;    FIXED_SIM_DURATION = 60.0  # Assumendo una durata fissa per ogni simulazione&#10;    for _ in scenarios:&#10;        exec_times_list.append(FIXED_SIM_DURATION)&#10;    return exec_times_list&#10;&#10;&#10;# --- Funzione per il Calcolo del Punteggio di Diversità ---&#10;&#10;def compute_div_scores(scenarios):&#10;    &quot;&quot;&quot;&#10;    Calcola il punteggio di diversità (div_score) per ogni scenario.&#10;    Gestisce campi presenti o assenti in base al tipo di evento.&#10;    &quot;&quot;&quot;&#10;    records = []&#10;&#10;    for idx, s in enumerate(scenarios):&#10;        record = {&#10;            &quot;id&quot;: idx,&#10;            &quot;town&quot;: s.get(&quot;town&quot;, None),&#10;            &quot;road_type_at_collision&quot;: s.get(&quot;road_type_at_collision&quot;, None)&#10;        }&#10;&#10;        record.update(s.get(&quot;weather&quot;, {}))&#10;        record.update(s.get(&quot;town_characteristics&quot;, {}))&#10;&#10;        records.append(record)&#10;&#10;    df = pd.DataFrame(records)&#10;&#10;    cat_cols = ['town']&#10;    if 'road_type_at_collision' in df.columns:&#10;        cat_cols.append('road_type_at_collision')&#10;&#10;    for col in cat_cols:&#10;        if col in df.columns:&#10;            df[col] = df[col].fillna('Unknown')&#10;&#10;    encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore')&#10;    cat_encoded_df = pd.DataFrame()&#10;    if not df.empty and any(col in df.columns for col in cat_cols):&#10;        actual_cat_cols = [col for col in cat_cols if col in df.columns]&#10;        if actual_cat_cols:&#10;            cat_encoded = encoder.fit_transform(df[actual_cat_cols])&#10;            cat_encoded_df = pd.DataFrame(cat_encoded, columns=encoder.get_feature_names_out(actual_cat_cols))&#10;&#10;    all_cols_except_id_cat = [col for col in df.columns if col not in [&quot;id&quot;] + cat_cols]&#10;&#10;    numeric_df = df[all_cols_except_id_cat].apply(pd.to_numeric, errors='coerce')&#10;    numeric_df = numeric_df.dropna(axis=1, how='all')&#10;    num_cols_final = numeric_df.columns.tolist()&#10;&#10;    scaler = MinMaxScaler()&#10;    num_scaled_df = pd.DataFrame()&#10;    if not numeric_df.empty:&#10;        num_scaled = scaler.fit_transform(numeric_df.fillna(0))&#10;        num_scaled_df = pd.DataFrame(num_scaled, columns=num_cols_final)&#10;&#10;    X = pd.concat([num_scaled_df.reset_index(drop=True), cat_encoded_df.reset_index(drop=True)], axis=1)&#10;&#10;    if X.empty or X.shape[0] &lt; 2:&#10;        print(&#10;            &quot;Avviso: Meno di 2 scenari o dati insufficienti per calcolare la diversità. Restituendo punteggi di diversità 0.&quot;)&#10;        return [0.0] * len(scenarios)&#10;&#10;    dist_matrix = pairwise_distances(X, metric='manhattan')&#10;&#10;    div_scores = [&#10;        np.mean(np.delete(dist_matrix[i], i))&#10;        for i in range(len(dist_matrix))&#10;    ]&#10;&#10;    return div_scores&#10;&#10;&#10;# --- Algoritmo Additional Greedy ---&#10;&#10;def additional_greedy(collisions, exec_times, divs, max_exec_time, all_scenarios):&#10;    &quot;&quot;&quot;&#10;    Implementa l'algoritmo Additional Greedy per selezionare un sottoinsieme di scenari.&#10;    &quot;&quot;&quot;&#10;    p = sum(collisions)&#10;&#10;    if p == 0:&#10;        print(&quot;Nessuna collisione registrata negli scenari di input. Selezionando tutti gli scenari per l'analisi.&quot;)&#10;        return list(range(len(all_scenarios)))&#10;&#10;    c = 0&#10;    selected_scenarios_indices = []&#10;    already_selected_set = set()&#10;&#10;    while c &lt; p:&#10;        weighted_sum_scores = {}&#10;        candidate_indices = [i for i in range(len(all_scenarios)) if i not in already_selected_set]&#10;&#10;        if not candidate_indices:&#10;            print(&quot;Avviso: Tutti gli scenari sono stati valutati, ma non tutte le collisioni sono state coperte.&quot;)&#10;            break&#10;&#10;        for scenario_idx in candidate_indices:&#10;            try:&#10;                normalized_exec_time = (exec_times[scenario_idx] / max_exec_time) if max_exec_time &gt; 0 else 1.0&#10;                if normalized_exec_time &lt; 0.0001:&#10;                    normalized_exec_time = 0.0001&#10;&#10;                score = ((0.5 * divs[scenario_idx]) + (0.5 * collisions[scenario_idx])) / normalized_exec_time&#10;                weighted_sum_scores[scenario_idx] = score&#10;            except Exception as e:&#10;                print(f&quot;Errore nel calcolo dello score per scenario {scenario_idx}: {e}. Saltando.&quot;)&#10;                continue&#10;&#10;        if not weighted_sum_scores:&#10;            print(&quot;Nessun scenario candidato con uno score valido è stato trovato. Interruzione.&quot;)&#10;            break&#10;&#10;        best_scenario_idx = max(weighted_sum_scores, key=weighted_sum_scores.get)&#10;        already_selected_set.add(best_scenario_idx)&#10;&#10;        if collisions[best_scenario_idx]:&#10;            c += 1&#10;&#10;        selected_scenarios_indices.append(best_scenario_idx)&#10;&#10;    return selected_scenarios_indices&#10;&#10;&#10;# --- Esecuzione Completa dello Script ---&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # --- Configurazione Path ---&#10;    input_folder = &quot;/Users/mariocelzo/Library/Mobile Documents/com~apple~CloudDocs/UNIVERSITA/TIROCINIO/adas_testing/simulation_output&quot;&#10;&#10;    current_timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')&#10;    analysis_output_folder = f&quot;analysis_results/run_{current_timestamp}&quot;&#10;    os.makedirs(analysis_output_folder, exist_ok=True)&#10;    print(f&quot;\n I risultati dell'analisi verranno salvati in: {os.path.abspath(analysis_output_folder)}&quot;)&#10;&#10;    # Step 1: Caricamento e pre-processing degli scenari&#10;    all_scenarios = load_scenarios_from_folder(input_folder)&#10;&#10;    if not all_scenarios:&#10;        print(&quot;Nessuno scenario da analizzare. Termino il programma.&quot;)&#10;        exit()&#10;&#10;    collisions = extract_collisions(all_scenarios)&#10;    exec_times = extract_exec_times(all_scenarios)&#10;    divs = compute_div_scores(all_scenarios)&#10;&#10;    max_exec_time = max(exec_times) if exec_times else 0.0&#10;    if max_exec_time == 0.0 and len(exec_times) &gt; 0:&#10;        max_exec_time = 1.0&#10;&#10;    print(f&quot;\n--- Riepilogo Caricamento Dati ---&quot;)&#10;    print(f&quot;Numero totale di scenari caricati: {len(all_scenarios)}&quot;)&#10;    print(f&quot;Flag collisioni (1=sì, 0=no): {collisions}&quot;)&#10;    print(f&quot;Tempi di esecuzione (secondi): {[f'{t:.2f}' for t in exec_times]}&quot;)&#10;    print(f&quot;Punteggi di diversità: {[f'{d:.3f}' for d in divs]}&quot;)&#10;    print(f&quot;Tempo di esecuzione massimo: {max_exec_time:.2f} secondi&quot;)&#10;&#10;    # Step 2: Stampa statistiche globali iniziali sull'intera suite&#10;    print(&quot;\n--- Statistiche Iniziali dell'Intera Suite di Scenari ---&quot;)&#10;    print(f&quot;Totale collisioni rilevate: {sum(collisions)}&quot;)&#10;    print(f&quot;Tempo totale di esecuzione combinato: {sum(exec_times):.2f} secondi&quot;)&#10;    print(f&quot;Somma dei punteggi di diversità: {sum(divs):.3f}&quot;)&#10;&#10;    # Step 3: Applicazione dell'algoritmo greedy per la selezione&#10;    print(&quot;\n--- Avvio Selezione Scenari con Algoritmo Greedy ---&quot;)&#10;    selected_scenario_indices = additional_greedy(collisions, exec_times, divs, max_exec_time, all_scenarios)&#10;&#10;    print(f&quot;\n--- Risultati Selezione Greedy ---&quot;)&#10;    print(f&quot;Numero di scenari selezionati: {len(selected_scenario_indices)}&quot;)&#10;    print(f&quot;Indici degli scenari selezionati: {selected_scenario_indices}&quot;)&#10;&#10;    # Step 4: Calcolo delle metriche per la suite selezionata&#10;    selected_collisions = [collisions[i] for i in selected_scenario_indices]&#10;    selected_exec_times = [exec_times[i] for i in selected_scenario_indices]&#10;    selected_divs = [divs[i] for i in selected_scenario_indices]&#10;&#10;    # Step 5: Stampa statistiche finali della suite selezionata&#10;    print(&quot;\n--- Statistiche della Suite di Scenari Selezionata ---&quot;)&#10;    print(f&quot;Totale collisioni coperte: {sum(selected_collisions)}&quot;)&#10;    print(f&quot;Tempo totale di esecuzione della suite selezionata: {sum(selected_exec_times):.2f} secondi&quot;)&#10;    print(f&quot;Somma dei punteggi di diversità della suite selezionata: {sum(selected_divs):.3f}&quot;)&#10;&#10;    # Step 6: Salvataggio dei risultati in un file JSON&#10;    analysis_results = {&#10;        &quot;input_folder&quot;: input_folder,&#10;        &quot;total_scenarios_analyzed&quot;: len(all_scenarios),&#10;        &quot;initial_suite_stats&quot;: {&#10;            &quot;total_collisions&quot;: sum(collisions),&#10;            &quot;total_execution_time_seconds&quot;: f&quot;{sum(exec_times):.2f}&quot;,&#10;            &quot;sum_diversity_scores&quot;: f&quot;{sum(divs):.3f}&quot;&#10;        },&#10;        &quot;greedy_algorithm_input_data&quot;: {&#10;            &quot;collisions&quot;: collisions,&#10;            &quot;exec_times&quot;: exec_times,&#10;            &quot;divs&quot;: divs,&#10;            &quot;max_exec_time&quot;: max_exec_time&#10;        },&#10;        &quot;selected_suite_stats&quot;: {&#10;            &quot;num_selected_scenarios&quot;: len(selected_scenario_indices),&#10;            &quot;selected_scenario_indices&quot;: selected_scenario_indices,&#10;            &quot;total_collisions_covered&quot;: sum(selected_collisions),&#10;            &quot;total_execution_time_seconds&quot;: f&quot;{sum(selected_exec_times):.2f}&quot;,&#10;            &quot;sum_diversity_scores&quot;: f&quot;{sum(selected_divs):.3f}&quot;&#10;        },&#10;        &quot;details_of_selected_scenarios&quot;: []&#10;    }&#10;&#10;    for idx in selected_scenario_indices:&#10;        scenario_data = all_scenarios[idx]&#10;        analysis_results[&quot;details_of_selected_scenarios&quot;].append({&#10;            &quot;index_in_original_list&quot;: idx,&#10;            &quot;original_filename&quot;: scenario_data.get('original_filename', 'N/A'),&#10;            &quot;event_type&quot;: scenario_data.get('event_type', 'N/A'),&#10;            &quot;timestamp_of_event&quot;: scenario_data.get('timestamp', 'N/A'),&#10;            &quot;map_town&quot;: scenario_data.get('town', 'N/A'),&#10;            &quot;road_type_at_collision&quot;: scenario_data.get('road_type_at_collision', 'N/A'),&#10;            &quot;weather_details&quot;: scenario_data.get('weather', {}),&#10;            &quot;town_characteristics&quot;: scenario_data.get('town_characteristics', {}),&#10;            &quot;diversity_score&quot;: f&quot;{divs[idx]:.3f}&quot;,&#10;            &quot;collision_flag&quot;: collisions[idx],&#10;            &quot;execution_time&quot;: exec_times[idx]&#10;        })&#10;&#10;    output_json_filename = os.path.join(analysis_output_folder, 'analysis_report.json')&#10;    with open(output_json_filename, 'w') as f:&#10;        json.dump(analysis_results, f, indent=4)&#10;    print(f&quot;✅ Report di analisi salvato in: {output_json_filename}&quot;)" />
              <option name="updatedContent" value="import os&#10;import json&#10;import numpy as np&#10;import pandas as pd&#10;from sklearn.preprocessing import MinMaxScaler, OneHotEncoder&#10;from sklearn.metrics import pairwise_distances&#10;from datetime import datetime&#10;&#10;&#10;# --- Funzioni di Caricamento e Estrazione Dati ---&#10;&#10;def load_scenarios_from_folder(folder_path):&#10;    &quot;&quot;&quot;&#10;    Carica tutti i file JSON da una cartella specificata, inclusi quelli nelle sottocartelle.&#10;    Ogni file JSON è atteso essere una LISTA di eventi.&#10;    Il codice estrarra' il PRIMO evento come rappresentativo dello scenario.&#10;    &quot;&quot;&quot;&#10;    scenarios = []&#10;    print(f&quot;Caricamento scenari dalla cartella: {folder_path} (e sottocartelle)&quot;)&#10;    if not os.path.exists(folder_path):&#10;        print(f&quot;⚠️ Attenzione: La cartella '{folder_path}' non esiste.&quot;)&#10;        return []&#10;&#10;    # Utilizza os.walk per attraversare l'albero delle directory&#10;    for root, _, files in os.walk(folder_path):&#10;        for filename in files:&#10;            if filename.endswith(&quot;.json&quot;):&#10;                file_path = os.path.join(root, filename)  # Usa 'root' per costruire il percorso completo&#10;                try:&#10;                    with open(file_path, 'r') as f:&#10;                        data = json.load(f)&#10;&#10;                        if isinstance(data, list) and data:&#10;                            if data:  # Assicurati che la lista non sia vuota&#10;                                scenario_event_data = data[0]&#10;                                scenario_event_data['original_filename'] = filename&#10;                                scenarios.append(scenario_event_data)&#10;                            else:&#10;                                print(f&quot;⚠️ Attenzione: Il file {filename} è una lista vuota. Saltato.&quot;)&#10;                        else:&#10;                            print(&#10;                                f&quot;❌ Errore: Il file {filename} non contiene una lista valida di eventi o ha un formato inatteso. Saltato.&quot;)&#10;&#10;                except json.JSONDecodeError as e:&#10;                    print(f&quot;❌ Errore di decodifica JSON nel file {filename}: {e}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;❌ Errore generico durante la lettura/elaborazione del file {filename}: {e}&quot;)&#10;    print(f&quot;Caricati {len(scenarios)} scenari.&quot;)&#10;    return scenarios&#10;&#10;&#10;def extract_collisions(scenarios):&#10;    &quot;&quot;&quot;&#10;    Estrae un flag binario (1 se c'è una collisione, 0 altrimenti) per ogni scenario.&#10;    Controlla 'event_type' direttamente nell'oggetto scenario (che è un singolo evento).&#10;    &quot;&quot;&quot;&#10;    collision_flags = []&#10;    for s in scenarios:&#10;        has_collision = 1 if s.get(&quot;event_type&quot;) == &quot;collision&quot; else 0&#10;        collision_flags.append(has_collision)&#10;    return collision_flags&#10;&#10;&#10;def extract_exec_times(scenarios):&#10;    &quot;&quot;&quot;&#10;    Estrae il tempo di esecuzione di ciascuno scenario.&#10;    Poiché il JSON non contiene 'simulation_duration_seconds' globale,&#10;    si assume una durata fissa.&#10;    &quot;&quot;&quot;&#10;    exec_times_list = []&#10;    FIXED_SIM_DURATION = 60.0  # Assumendo una durata fissa per ogni simulazione&#10;    for _ in scenarios:&#10;        exec_times_list.append(FIXED_SIM_DURATION)&#10;    return exec_times_list&#10;&#10;&#10;# --- Funzione per il Calcolo del Punteggio di Diversità ---&#10;&#10;def compute_div_scores(scenarios):&#10;    &quot;&quot;&quot;&#10;    Calcola il punteggio di diversità (div_score) per ogni scenario.&#10;    Gestisce campi presenti o assenti in base al tipo di evento.&#10;    &quot;&quot;&quot;&#10;    records = []&#10;&#10;    for idx, s in enumerate(scenarios):&#10;        record = {&#10;            &quot;id&quot;: idx,&#10;            &quot;town&quot;: s.get(&quot;town&quot;, None),&#10;            &quot;road_type_at_collision&quot;: s.get(&quot;road_type_at_collision&quot;, None)&#10;        }&#10;&#10;        record.update(s.get(&quot;weather&quot;, {}))&#10;        record.update(s.get(&quot;town_characteristics&quot;, {}))&#10;&#10;        records.append(record)&#10;&#10;    df = pd.DataFrame(records)&#10;&#10;    cat_cols = ['town']&#10;    if 'road_type_at_collision' in df.columns:&#10;        cat_cols.append('road_type_at_collision')&#10;&#10;    for col in cat_cols:&#10;        if col in df.columns:&#10;            df[col] = df[col].fillna('Unknown')&#10;&#10;    encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore')&#10;    cat_encoded_df = pd.DataFrame()&#10;    if not df.empty and any(col in df.columns for col in cat_cols):&#10;        actual_cat_cols = [col for col in cat_cols if col in df.columns]&#10;        if actual_cat_cols:&#10;            cat_encoded = encoder.fit_transform(df[actual_cat_cols])&#10;            cat_encoded_df = pd.DataFrame(cat_encoded, columns=encoder.get_feature_names_out(actual_cat_cols))&#10;&#10;    all_cols_except_id_cat = [col for col in df.columns if col not in [&quot;id&quot;] + cat_cols]&#10;&#10;    numeric_df = df[all_cols_except_id_cat].apply(pd.to_numeric, errors='coerce')&#10;    numeric_df = numeric_df.dropna(axis=1, how='all')&#10;    num_cols_final = numeric_df.columns.tolist()&#10;&#10;    scaler = MinMaxScaler()&#10;    num_scaled_df = pd.DataFrame()&#10;    if not numeric_df.empty:&#10;        num_scaled = scaler.fit_transform(numeric_df.fillna(0))&#10;        num_scaled_df = pd.DataFrame(num_scaled, columns=num_cols_final)&#10;&#10;    X = pd.concat([num_scaled_df.reset_index(drop=True), cat_encoded_df.reset_index(drop=True)], axis=1)&#10;&#10;    if X.empty or X.shape[0] &lt; 2:&#10;        print(&#10;            &quot;Avviso: Meno di 2 scenari o dati insufficienti per calcolare la diversità. Restituendo punteggi di diversità 0.&quot;)&#10;        return [0.0] * len(scenarios)&#10;&#10;    dist_matrix = pairwise_distances(X, metric='manhattan')&#10;&#10;    div_scores = [&#10;        np.mean(np.delete(dist_matrix[i], i))&#10;        for i in range(len(dist_matrix))&#10;    ]&#10;&#10;    return div_scores&#10;&#10;&#10;# --- Algoritmo Additional Greedy ---&#10;&#10;def additional_greedy(collisions, exec_times, divs, max_exec_time, all_scenarios):&#10;    &quot;&quot;&quot;&#10;    Implementa l'algoritmo Additional Greedy per selezionare un sottoinsieme di scenari.&#10;    &quot;&quot;&quot;&#10;    p = sum(collisions)&#10;&#10;    if p == 0:&#10;        print(&quot;Nessuna collisione registrata negli scenari di input. Selezionando tutti gli scenari per l'analisi.&quot;)&#10;        return list(range(len(all_scenarios)))&#10;&#10;    c = 0&#10;    selected_scenarios_indices = []&#10;    already_selected_set = set()&#10;&#10;    while c &lt; p:&#10;        weighted_sum_scores = {}&#10;        candidate_indices = [i for i in range(len(all_scenarios)) if i not in already_selected_set]&#10;&#10;        if not candidate_indices:&#10;            print(&quot;Avviso: Tutti gli scenari sono stati valutati, ma non tutte le collisioni sono state coperte.&quot;)&#10;            break&#10;&#10;        for scenario_idx in candidate_indices:&#10;            try:&#10;                normalized_exec_time = (exec_times[scenario_idx] / max_exec_time) if max_exec_time &gt; 0 else 1.0&#10;                if normalized_exec_time &lt; 0.0001:&#10;                    normalized_exec_time = 0.0001&#10;&#10;                score = ((0.5 * divs[scenario_idx]) + (0.5 * collisions[scenario_idx])) / normalized_exec_time&#10;                weighted_sum_scores[scenario_idx] = score&#10;            except Exception as e:&#10;                print(f&quot;Errore nel calcolo dello score per scenario {scenario_idx}: {e}. Saltando.&quot;)&#10;                continue&#10;&#10;        if not weighted_sum_scores:&#10;            print(&quot;Nessun scenario candidato con uno score valido è stato trovato. Interruzione.&quot;)&#10;            break&#10;&#10;        best_scenario_idx = max(weighted_sum_scores, key=weighted_sum_scores.get)&#10;        already_selected_set.add(best_scenario_idx)&#10;&#10;        if collisions[best_scenario_idx]:&#10;            c += 1&#10;&#10;        selected_scenarios_indices.append(best_scenario_idx)&#10;&#10;    return selected_scenarios_indices&#10;&#10;&#10;# --- Esecuzione Completa dello Script ---&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # --- Configurazione Path ---&#10;    input_folder = &quot;/Users/mariocelzo/Library/Mobile Documents/com~apple~CloudDocs/UNIVERSITA/TIROCINIO/adas_testing/simulation_output&quot;&#10;&#10;    current_timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')&#10;    analysis_output_folder = f&quot;analysis_results/run_{current_timestamp}&quot;&#10;    os.makedirs(analysis_output_folder, exist_ok=True)&#10;    print(f&quot;\n I risultati dell'analisi verranno salvati in: {os.path.abspath(analysis_output_folder)}&quot;)&#10;&#10;    # Step 1: Caricamento e pre-processing degli scenari&#10;    all_scenarios = load_scenarios_from_folder(input_folder)&#10;&#10;    if not all_scenarios:&#10;        print(&quot;Nessuno scenario da analizzare. Termino il programma.&quot;)&#10;        exit()&#10;&#10;    collisions = extract_collisions(all_scenarios)&#10;    exec_times = extract_exec_times(all_scenarios)&#10;    divs = compute_div_scores(all_scenarios)&#10;&#10;    max_exec_time = max(exec_times) if exec_times else 0.0&#10;    if max_exec_time == 0.0 and len(exec_times) &gt; 0:&#10;        max_exec_time = 1.0&#10;&#10;    print(f&quot;\n--- Riepilogo Caricamento Dati ---&quot;)&#10;    print(f&quot;Numero totale di scenari caricati: {len(all_scenarios)}&quot;)&#10;    print(f&quot;Flag collisioni (1=sì, 0=no): {collisions}&quot;)&#10;    print(f&quot;Tempi di esecuzione (secondi): {[f'{t:.2f}' for t in exec_times]}&quot;)&#10;    print(f&quot;Punteggi di diversità: {[f'{d:.3f}' for d in divs]}&quot;)&#10;    print(f&quot;Tempo di esecuzione massimo: {max_exec_time:.2f} secondi&quot;)&#10;&#10;    # Step 2: Stampa statistiche globali iniziali sull'intera suite&#10;    print(&quot;\n--- Statistiche Iniziali dell'Intera Suite di Scenari ---&quot;)&#10;    print(f&quot;Totale collisioni rilevate: {sum(collisions)}&quot;)&#10;    print(f&quot;Tempo totale di esecuzione combinato: {sum(exec_times):.2f} secondi&quot;)&#10;    print(f&quot;Somma dei punteggi di diversità: {sum(divs):.3f}&quot;)&#10;&#10;    # Step 3: Applicazione dell'algoritmo greedy per la selezione&#10;    print(&quot;\n--- Avvio Selezione Scenari con Algoritmo Greedy ---&quot;)&#10;    selected_scenario_indices = additional_greedy(collisions, exec_times, divs, max_exec_time, all_scenarios)&#10;&#10;    print(f&quot;\n--- Risultati Selezione Greedy ---&quot;)&#10;    print(f&quot;Numero di scenari selezionati: {len(selected_scenario_indices)}&quot;)&#10;    print(f&quot;Indici degli scenari selezionati: {selected_scenario_indices}&quot;)&#10;&#10;    # Step 4: Calcolo delle metriche per la suite selezionata&#10;    selected_collisions = [collisions[i] for i in selected_scenario_indices]&#10;    selected_exec_times = [exec_times[i] for i in selected_scenario_indices]&#10;    selected_divs = [divs[i] for i in selected_scenario_indices]&#10;&#10;    # Step 5: Stampa statistiche finali della suite selezionata&#10;    print(&quot;\n--- Statistiche della Suite di Scenari Selezionata ---&quot;)&#10;    print(f&quot;Totale collisioni coperte: {sum(selected_collisions)}&quot;)&#10;    print(f&quot;Tempo totale di esecuzione della suite selezionata: {sum(selected_exec_times):.2f} secondi&quot;)&#10;    print(f&quot;Somma dei punteggi di diversità della suite selezionata: {sum(selected_divs):.3f}&quot;)&#10;&#10;    # Step 6: Salvataggio dei risultati in un file JSON&#10;    analysis_results = {&#10;        &quot;input_folder&quot;: input_folder,&#10;        &quot;total_scenarios_analyzed&quot;: len(all_scenarios),&#10;        &quot;initial_suite_stats&quot;: {&#10;            &quot;total_collisions&quot;: sum(collisions),&#10;            &quot;total_execution_time_seconds&quot;: f&quot;{sum(exec_times):.2f}&quot;,&#10;            &quot;sum_diversity_scores&quot;: f&quot;{sum(divs):.3f}&quot;&#10;        },&#10;        &quot;greedy_algorithm_input_data&quot;: {&#10;            &quot;collisions&quot;: collisions,&#10;            &quot;exec_times&quot;: exec_times,&#10;            &quot;divs&quot;: divs,&#10;            &quot;max_exec_time&quot;: max_exec_time&#10;        },&#10;        &quot;selected_suite_stats&quot;: {&#10;            &quot;num_selected_scenarios&quot;: len(selected_scenario_indices),&#10;            &quot;selected_scenario_indices&quot;: selected_scenario_indices,&#10;            &quot;total_collisions_covered&quot;: sum(selected_collisions),&#10;            &quot;total_execution_time_seconds&quot;: f&quot;{sum(selected_exec_times):.2f}&quot;,&#10;            &quot;sum_diversity_scores&quot;: f&quot;{sum(selected_divs):.3f}&quot;&#10;        },&#10;        &quot;details_of_selected_scenarios&quot;: []&#10;    }&#10;&#10;    for idx in selected_scenario_indices:&#10;        scenario_data = all_scenarios[idx]&#10;        analysis_results[&quot;details_of_selected_scenarios&quot;].append({&#10;            &quot;index_in_original_list&quot;: idx,&#10;            &quot;original_filename&quot;: scenario_data.get('original_filename', 'N/A'),&#10;            &quot;event_type&quot;: scenario_data.get('event_type', 'N/A'),&#10;            &quot;timestamp_of_event&quot;: scenario_data.get('timestamp', 'N/A'),&#10;            &quot;map_town&quot;: scenario_data.get('town', 'N/A'),&#10;            &quot;road_type_at_collision&quot;: scenario_data.get('road_type_at_collision', 'N/A'),&#10;            &quot;weather_details&quot;: scenario_data.get('weather', {}),&#10;            &quot;town_characteristics&quot;: scenario_data.get('town_characteristics', {}),&#10;            &quot;diversity_score&quot;: f&quot;{divs[idx]:.3f}&quot;,&#10;            &quot;collision_flag&quot;: collisions[idx],&#10;            &quot;execution_time&quot;: exec_times[idx]&#10;        })&#10;&#10;    output_json_filename = os.path.join(analysis_output_folder, 'analysis_report.json')&#10;    with open(output_json_filename, 'w') as f:&#10;        json.dump(analysis_results, f, indent=4)&#10;    print(f&quot;✅ Report di analisi salvato in: {output_json_filename}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>